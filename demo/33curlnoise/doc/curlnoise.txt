# Simulating fluids with compute shaders #

##################
## Introduction ##
##################

This sample uses OpenGL ES 3.1 and compute shaders to seamlessly advect tens of thousands of particles.
We use a combination of potential flow theory and procedural noise, to simulate the turbulent wake
of smoke moving around an interactive object. 

After simulation, the particles are sorted using a GPU-accelerated mergesort, 
and then rendered as alphablended sprites with volumetric shadows.

The approach presented is cheap compared to more accurate fluid simulations, 
and produces good-looking visuals for use in real-time applications.

############################################
## A brief introduction to fluid dynamics ##
############################################

We simulate the flow by generating a velocity field for our scene. The velocity field
is a 3D vector function, which tells us how fast a particle is moving at any point in space.
For fluids that are incompressible, it's important that this field is divergence-free. That is - 
it doesn't clump together anywhere.

Luckily for us though, it turns out that we can do this easily with some clever mathematics! 
First of all, our field will consist of two parts. The first is a repulsive component close 
to the object that will push the smoke away. We generate this by using a source potential
from ideal-flow theory, which is a scalar function defined as
	
	phi = -a * ln(r + e),

where ``r`` is the distance from the origin of the point evaluated. 
The velocity can be computed directly by taking the gradient of this function. 
The result is a field which is divergence-free everywhere but the origin. 
To eliminate the singularity at the origin, we add a small epsilon term ``e``.

The second component is a procedural noise field, which will simulate the turbulent wake further away
from the object. It can be shown that if we use a noise function which is smooth (in the mathematical sense), 
the curl of the function becomes a divergence-free vector field. The final velocity field is simply the sum of the two components. 

Details of this technique can be found in [2] and in the sample code provided.

###############################
## Storing the particle data ##
###############################

To simulate the particles we need to keep track of their position in space. In addition, we give each particle
a certain lifetime, which decreases over time. When the life runs out, the particle respawns at a convenient location.
We store this information in shader storage buffer objects, which are special buffers that can be both read from and
written to inside the compute shader.

	void init_particles()
	{
		vec4 *data = new vec4[NUM_PARTICLES];
		for (int i = 0; i < NUM_PARTICLES; ++i)
		{
			vec3 p = random_position();
			float lifetime = PARTICLE_LIFETIME;
			data[i] = vec4(p, lifetime);
		}
		glGenBuffers(1, &position_buffer);
		glBindBuffer(GL_SHADER_STORAGE_BUFFER, position_buffer);
		glBufferData(GL_SHADER_STORAGE_BUFFER, NUM_PARTICLES * sizeof(vec4), data, GL_DYNAMIC_DRAW);
		glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
		delete[] data;
	}

Note that while we only need three components to store the position, the rules of the GLES spec state that we would have to align
the data to 32 bytes (a vec4) anyway. So we take advantage of that and store the particle's lifetime as the w component, 
instead of in its own buffer. This also causes a slight speedup by having fewer buffer lookups in the shaders.

#####################
## Compute shaders ##
#####################

Compute shaders are a new addition to GLES. These shaders are programs that run on the GPU, outside of the normal rendering pipeline.
An advantage of compute shaders over OpenCL or CUDA, is that they can be easily integrated with your application, without the need
to install additional libraries. Furthermore, they are written in GLSL syntax, with all that swizzling and matrix math glory.
And like other GLSL shaders, they can read textures, images and buffers and write to images and buffers.

Similiar to other GPGPU implementations, threads are grouped into work groups and one shader invocation processes a bunch of them
independently.

Here's a minimal example of a compute shader

	#version 310 es
	layout (local_size_x = 16) in;
	layout (binding = 0) buffer DataBuffer {
		float Data[];
	};

	void main()
	{
		uint index = gl_GlobalInvocationID.x;
		Data[index] *= 2.0;
	}

The example takes a buffer as input, and multiplies each value in the buffer by two.
While the syntax is similiar to GLSL, there are some new important keywords.

First we have the parameter local_size_x, which says how many work items are executed inside
a single work group. When invoked, the shader program is run once for every work item you have, 
and items inside the same group can be assumed to be run in parallell. 

Second, we have gl_GlobalInvocationID.x, which is the index of the current work item relative the
total set of work items. Note that the space is three-dimensional, so we have similiar parameters
for the y- and z-axis.

The following code runs the shader.

	// Generate buffer and fill with data
	GLuint buffer;
	glGenBuffers(1, &buffer);
	// ...

	glUseProgram(program);
	glDispatchCompute(num_elements / local_size_x, 1, 1);

###########################
## Understanding indices ##
###########################

You might be scratching your head at this point, so let's try to understand by drawing a picture.

	#version 310 es
	layout (local_size_x = 16, local_size_y = 16) in;
	layout (binding = 0, rgba16f) uniform writeonly image2D tex;
	const int TEXTURE_SIZE_X = 128;
	const int TEXTURE_SIZE_Y = 128;
	void main()
	{
		// The integer coordinate texture coordinate (from 0 to TEXTURE_SIZE_XY - 1)
		ivec2 texel = ivec2(gl_GlobalInvocationID.xy);

		// Left
	    // float u = float(gl_GlobalInvocationID.x) / TEXTURE_SIZE_X;
	    // float v = float(gl_GlobalInvocationID.y) / TEXTURE_SIZE_Y;
	    // imageStore(tex, texel, vec4(u, v, 0.0, 1.0));

	    // Middle
	    // float u = float(gl_WorkGroupID.x) / gl_NumWorkGroups.x;
	    // float v = float(gl_WorkGroupID.y) / gl_NumWorkGroups.y;
	    // imageStore(tex, texel, vec4(u, v, 0.0, 1.0));

	    // Right
	    // float u = float(gl_LocalInvocationID.x) / gl_WorkGroupSize.x;
	    // float v = float(gl_LocalInvocationID.y) / gl_WorkGroupSize.y;
	    // imageStore(tex, texel, vec4(u, v, 0.0, 1.0));
	}

This shader has three commented sections which write different results to an output texture.
We can run this shader by doing

	// Create empty 128x128 texture, load program
	GLuint texture;
	GLuint program;
	// ...

	glUseProgram(program);
	glDispatchCompute(
		TEXTURE_SIZE_X / LOCAL_SIZE_X,
		TEXTURE_SIZE_Y / LOCAL_SIZE_Y,
		1);

And this is what we get

	[img]

################
## Simulation ##
################

The simulation is done using single-pass compute shaders. For each particle, we evaluate the velocity field at the particle's position, 
and do simple Euler-integration to forward the simulation. Because each particle is independent from the rest, 
this type of simulation is a perfect job for the GPU. The simplified code below shows how the update shader works.

	#version 310 es
	layout (local_size_x = 64) in;
	layout (std140, binding = 0) buffer ParticleBuffer {
		vec4 Particle[];
	};
	layout (std140, binding = 1) buffer SpawnBuffer {
		vec4 SpawnInfo[];
	};

	// ...

	void main()
	{
		uint index = gl_GlobalInvocationID.x;
		vec4 status = Particle[index];
		vec3 position = status.xyz;
		float lifetime = status.w;

		if (lifetime < 0)
		{
			Particle[index] = SpawnInfo[index];
		}
		else
		{
			vec3 velocity = evaluateVelocity(position);
			position += velocity * timestep;
			lifetime -= timestep;
			Particle[index] = vec4(position, lifetime);
		}
	}

First, we declare a work group size of 64, which is the highest (?) for the tablet this code run on.
The ParticleBuffer input contains each particle's position and lifetime, while the SpawnBuffer contains
new values for these, should the particle need to respawn.

The std140 layout specifier tells OpenGL that we want a standardized alignment of the elements in the buffer - 
i.e. not implementation-dependent.

########################
## Particle rendering ##
########################
We render the particles as point sprites with radial falloff to appear more transparent near the edges.


The final accumulated shadow buffer can be used to shade the rest of the scene. It works

 the attenuation of light as it travels through the smoke, the particles are sorted
from front-to-back relative to the light, and then drawn in additive batches to the shadow map.

#############
## Sorting ##
#############

To achieve order-correct alphablending and proper volumetric lighting, as described in the next section, 
we need a way to sort the particles. We can avoid sorting

By sorting along an axis which is halfway between the eye's and the 
light's viewing axis, the order is approximately correct from both point of views. This way we avoid sorting twice.

We attenuate the light by summing up opacity as we get deeper into the medium. This means that the particles
should be sorted in front-to-back order from the light.


After the shadow pass, correct alphablending is done by rendering the particles front-to-back, if the 
light and eye are looking in the same direction, or back-to-front otherwise.

The particles are sorted by increasing distance along the halfangle axis.



## Collision with objects ##
Ramp down tangential component of the potential function near the boundary.

	float alpha = abs(ramp(distance / regionLength));
	return alpha * psi + (1.0 - alpha) * dot(normal, psi) * normal;

	[1]: http://en.wikipedia.org/wiki/Potential_flow
	[2]: http://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph2007-curlnoise.pdf
	[3]: http://www.naic.edu/~phil/hardware/nvidia/doc/src/smokeParticles/doc/smokeParticles.pdf
	[4]: http://wili.cc/blog/opengl-cs.html
	[5]: http://www.opengl.org/wiki/Compute_Shader
	[6]: http://twvideo01.ubm-us.net/o1/vault/GDC2014/Presentations/Gareth_Thomas_Compute-based_GPU_Particle.pdf
	[7]: http://http.developer.nvidia.com/GPUGems/gpugems_ch39.html
	[8]: http://directtovideo.wordpress.com/2009/10/06/a-thoroughly-modern-particle-system/
	[9]: http://www.codeproject.com/Articles/543451/Parallel-Radix-Sort-on-the-GPU-using-Cplusplus-AMP
	[10]: http://www.heterogeneouscompute.org/wordpress/wp-content/uploads/2011/06/RadixSort.pdf

