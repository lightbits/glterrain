Today I just finished working on my procedural terrain geometry generator which I intend to use in an upcoming rts game :) . There is no textures or anything else yet, just pure geometry and some basic lighting. I managed to set simulation parameters to adapt it for real time visualisation of hydraulic and thermal erosion. I've also been working on procedural path generator to create roads that avoid steep climbs and other obstacles. I hope you like it and let me know what you think :)

The project consists of four major parts:
procedural generation of random terrain
water simulation
erosion simulation
procedural road generation
Part one
First we need to create a random terrain, for which I used diamond-square algorithm, since it's really intuitive and fast. It manages to create just enough details that we'll need later on. Throughout the project I was using grid size of 513*513, because diamond-square generates heightmaps of size n2 + 1.
Part two
For water flow simulation I used shallow water equations. Now here's the tricky part. There is just no way that you could simulate water flow on CPU (on such size of the grid) in real time. So I had to find a model, that would allow me to simulate those equations on a gpu. luckily, there actually is one, from year 1995 :) The name ofthe article is Dynamic Simulation of Splashing Fluids and it describes a model of virtual pipes which enables us to translate this problem to GPU. For those who are not familiar with GPU programming, not all algorithms can be parallelized. The problem is that on GPU, you have to use textures in order to efficiently compute data on gpu. The main problem here is that you can only write to texture coordinate that GPU is currently working on, if not you could corrupt the output data from other GPU cores/processors. Now with this virtual pipe model you can simulate shallow water equations on GPU in real time.
Part three
After we computed the simulation of water flow, we need to compute velocity vecotrs of water flow. This is needed for computing how much sediment can water carry with it. Everything is described here. Now that we've determined sediment transport capacity, we can each time take a bit of terrain regarding ammount of water, water speed and local tilt angle and add it to suspended sediment data texture. In next step we use the direction of water flow to transport sediment down the stream. For more detailed description I'd recommend reading this article which helped me a lot, but I had to make a lot of changes to make it look like it looks atm and I'm still not satisfied.
Part four
Now this is my favorite part, but it's a bit complicated. I haven't found an algorithm which would describe how to procedurally generate geometry of the roads, so did it on my own. Road also has to go from point A to point B in the most energy efficient way, since it's better to walk/drive longer distance and climb slowly than make a fast and steep ascend. Firstly I had to find a path which would connect all vertices on a grid in to a smooth path. That's a fairly simple task when you know how to use A* and how to find a proper heuristic function for it. I used a function which describes how much energy do you consume for moving 1m at certain angle. You can find a detailed description in this article (sorry, didn't find any free version of it). Now we should get a jagged path but noone really wants to look at those. That's why we have to interpolate or in my case just subdivide points to make them smooth. You can also use BÃ©zier curves, but I prefer basic subdivision and it also works way faster :) Now we need to construct a road(the actual surface to walk/drive on) and a verge. To make a road we need to split path in small chunks called segments. A segment is just a quad which is stretched between four points. To define those points we also need to define a spine of the segment, which is a line going from one to the next point in list of all points that define the path. Now, we can get those four points by connecting 3 spines. By doing that we get 2 points where spines touch. At those two points we need to draw a line, which halves the angle between those spines. On each side of that halving line we determine a point at the appropriate distance from sipne(pathWidth*angleCoefficient). We do the same on the other side of the current spine and that's how we get four points that define a segment. I know it's kind of hard to understand this without the supporting images, but i'll try to incorporate those in a blog/site. Now, we just need to find points on the heightmap that fit into this segment and move them to the height of the segment begining or end. Verge is made in a similar way but we need to interpolate height with smooth step function in order to merge it properly with the terrain. If we do this for each next segment, we'll get a nice path, but we still need to smooth it with average or some other simple smoothing function.